<!DOCTYPE html>
<html>
<head>
<title>Pred class</title>
<style>
  pre i {font-family: serif; }
</style>
</head>
<body>
<p ALIGN="right"><EM>
<b>Pred&nbsp;1.4</b></EM>
</p>
<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
io.github.JalogTeam.jalog</FONT>
<BR>
Class Pred</H2>
<PRE>
<B>java.lang.Object</B>
  <IMG SRC="inherit.png" ALT="extended by "><B>io.github.JalogTeam.jalog.Pred</B>
</PRE>
<HR>
<DL>
  <DT>
    <PRE>public class <B>Pred</B>
    </PRE>
  </DT>
</DL>
<P>
Class <code>Pred</code> is the base class for all classes that implement Prolog primitive predicates.
</p>
<p>
For each built-in predicate a subclass of <code>Pred</code> is needed.  Each built in predicate must be introduced in <A href="BuiltIns_class_doc.html"><code>BuiltIns</code></A> class.
</p>
<p>Each subclass of <code>Pred</code> must implement the static method <code>first_call</code>.
</p>
<p>If other results are possibly produced on backtrack, <code>first_call</code> must 
create an object of this subclass and initialize it with any data that
is needed on backtrack. The created object must be returned as the value
of this function.
</p>
<p>Another case where an object of this class must be created and returned
is when post processing is needed after calling Prolog code (which may be received by a parameter or otherwise). 
</p>
<p>If no action is needed after returning from <code>first_call</code> <code>
null</code> should be returned.
</p>
<p>If <code>first_call</code> always returns 
<code>null</code> no other methods should be implemented.
</p>
<p
<p>Other methods of <code>Pred</code> may be overridden as needed.
</p>
<p id="calling_pattern">
General structure of a subclass of <code>Pred</code>:
</p>
<pre>
    public class Pred_<i>example</i> extends Pred
    {
      ... // declarations as needed

      public static Pred first_call(Pro_TermData_Compound params) {

        Pred_<i>example</i> result = null;
    /*
        You may want to take parameters to local variables:
    */    
        Pro_Term <i>first_param</i> = params.subterm[0].getRealNode();
        Pro_Term <i>second_param</i> = params.subterm[1].getRealNode();
        ...
        Pro_Term <i>result_term</i> = params.subterm[<i>n</i>].getRealNode();

        ... // declarations as needed

    /*
        Identify flow pattern and act accordingly.
        <i>_param</i>.data == null means an open variable.
    */    
        if (<i>first_param</i>.data != null) 
        {  // <i>first_param</i> is bound
          if (<i>second_param</i>.data != null) 
          {  // <i>second_param</i> is bound
            ...
            // compute <i>result_value</i>
            Pro_Term <i>result_value</i> = Pro_Term.<i>type</i>(...);
            
            
          } else { // <i>second_param</i> is open
          
            
            
            
          Pro_Term so = Pro_Term.m_string_concat(
              (Pro_TermData_String)left_term.data, 
              (Pro_TermData_String)right_term.data);
        
          result = new Pred__eq_(
              new Pro_TermData_Compound("=", so, result_term));
          result.call();
      Pro_Term.debug = 0;
        } else if (left_term.data != null && result_term.data != null) {
          len_left = ((Pro_TermData_String)left_term.data).len;
          len = ((Pro_TermData_String)result_term.data).len;
          left_part = Pro_Term.m_string_substring(
              (Pro_TermData_String)result_term.data, 0, len_left);
          result = new Pred__eq_(
              new Pro_TermData_Compound("=", left_term, left_part));
          result.call();
          if (Pred.forward) {
            right_part = Pro_Term.m_string_substring(
                (Pro_TermData_String)result_term.data, len_left, 
                len - len_left);
            result = new Pred__eq_(
                new Pro_TermData_Compound("=", right_term, right_part));
            result.call();
          }
        } else if (right_term.data != null && result_term.data != null) {
          len_right = ((Pro_TermData_String)right_term.data).len;
          len = ((Pro_TermData_String)result_term.data).len;
          right_part = Pro_Term.m_string_substring(
              (Pro_TermData_String)result_term.data, len - len_right, 
              len_right);
          result = new Pred__eq_(
              new Pro_TermData_Compound("=", right_term, right_part));
          result.call();
          if (Pred.forward) {
            left_part = Pro_Term.m_string_substring(
                (Pro_TermData_String)result_term.data, 0, len - len_right);
            result = new Pred__eq_(
                new Pro_TermData_Compound("=", left_term, left_part));
            result.call();
          }
        } else {
          Pred.forward = false;  // invalid flow pattern (o,o,o) (i,o,o),(o,i,o),(o,o,i)
        }
        return null;
      }
      <span style="color:red;">Something should be said about recall.</span>

      <span style="color:red;">Something should be said about post_call.</span>

    }
</pre>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<a href="Pro_Term_class_doc.html"><CODE>Pro_Term</CODE></a></FONT></TD>
<TD><CODE><B><A HREF="#called_body">called_body</A></B></CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Used in e.g. <code>not</code>.</TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="#cut">cut</A></B></CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Used in <code>cut</code>.</TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="#cutting">cutting</A></B></CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Used in <code>cut</code>.</TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="#exception">exception</A></B></CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Set in e.g. <code>exit</code>.</TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static <a href="Pro_Term_class_doc.html">Pro_Term</a></CODE></FONT></TD>
<TD><CODE><B><A HREF="#exit_value">exit_value</A></B></CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Set in e.g. <code>exit</code>.</TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="#forward">forward</A></B></CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Value <code>true</code> controls and indicates forward execution.</TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<a href="Pro_TrailMark_class_doc.html"><CODE>Pro_TrailMark</CODE></a></FONT></TD>
<TD><CODE><B><A HREF="#Mark">Mark</A></B></CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Controls backtracking of unifications.</TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="#op_found">op_found</A></B></CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Set <code>true</code> when right code for this predicate.</TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<code>public static </code><a href="Pro_Trail_class_doc.html"><CODE>Pro_Trail</CODE></a></FONT></TD>
<TD><CODE><B><A HREF="#trail">trail</A></B></CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Controls backtracking of unifications.</TD>
</TR>


</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<!--
<A NAME="constructor_summary"></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="#Pred">Pred</A></B>()</CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Constructs a <CODE>Pred</CODE> instance.</TD>
</TR>

</TABLE>
&nbsp;
-->
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
  <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
    <CODE>&nbsp;public void</CODE></FONT>
  </TD>
  <TD>
    <CODE><B><A HREF="#call">call</A></B>()</CODE>

    <BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Called in backtrack.
   </TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
  <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
    <CODE>&nbsp;public static Pred</CODE></FONT>
  </TD>
  <TD>
    <CODE><B><A HREF="#first_call">first_call</A></B>(<a href="Pro_TermData_Compound_class_doc.html">Pro_TermData_Compound</a> params)</CODE>

    <BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Called when the predicate is executed first time.
   </TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
  <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
    <CODE>&nbsp;public void</CODE></FONT>
  </TD>
  <TD>
    <CODE><B><A HREF="#post_call">post_call</A></B>()</CODE>

    <BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Called e.g. in <code>not</code> after sub predicates are executed.
   </TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
  <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
    <CODE>&nbsp;public String</CODE></FONT>
  </TD>
  <TD>
    <CODE><B><A HREF="#toString">toString</A></B>()</CODE>

    <BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Converts predicate status to string for debugging.
   </TD>
</TR>

</TABLE>
&nbsp;
<P>
<!-- ============ FIELD DETAIL =========== -->
<TABLE id="field_detail" BORDER="1" WIDTH="100%" CELLPADDING="3" 
CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>


<H3 id="called_body">called_body</H3>
<PRE>
<a href="Pro_Term_class_doc.html"><CODE>Pro_Term</CODE></A> <B>called_body</B></PRE>
<DL>
<DD>Initialized to <code>null</code>. Rarely needed. 
<P>This field is needed when Jalog code is executed by a built-in predicate. The value to be assigned must be a list that can be interpreted as a predicate body. The list is executed after returning from the method that has set the <code>called_body</code>.</P>
<P>Typically <code>called_body</code> is a singlet list containing a subterm of <code>params</code> received in <code>first_call</code>.
</DD>
</DL>
<HR>

<H3 id="cut">cut</H3>
<PRE>
<CODE>boolean</CODE> <B>cut</B></PRE>
<DL>
<DD>Used in <code>cut</code> predicate. Rarely needed otherwise.
<P>Usually <code>false</code>. If set in <code>first_call</code>, the calling clause is not backtracked behind the call of this predicate.
</P>
</DD>
</DL>
<HR>

<H3 id="cutting">cutting</H3>
<PRE>
<CODE>boolean</CODE> <B>cutting</B></PRE>
<DL>
<DD>Used in <code>cut</code> predicate. Rarely needed otherwise.
<P>Usually <code>false</code>. If set in <code>call</code> when <code>forward</code> is <code>false</code>, the remaining clauses of the calling predicate are not called. Instead, the predicate fails.</P>
</DD>
</DL>
<HR>

<H3 id="exception">exception</H3>
<PRE>
<CODE>boolean</CODE> <B>exception</B></PRE>
<DL>
<DD>Set in <code>exit</code>. Otherwise used in error situations.
<P>Transfers execution to the exception handler argument of the latest active <code>trap</code> call, or exits the program if none is active. When set the <code>exit_value</code> must be set to desired exit code.
</DD>
</DL>
<HR>

<H3 id="exit_value">exit_value</H3>
<PRE>
<a href="Pro_Term_class_doc.html"><CODE>Pro_Term</CODE></A> <B>exit_value</B></PRE>
<DL>
<DD>The desired exit code. Needed when <code>exception</code> is set. Should be an integer.
</DD>
</DL>
<HR>

<H3 id="forward">forward</H3>
<PRE>
<CODE>boolean</CODE> <B>forward</B></PRE>
<DL>
<DD>The value indicates and controls the direction of execution.
<P>On entry to <code>call</code> or <code>post_call</code> <code>true</code> indicates forward execution and <code>false</code> indicates backtracking.</P>
<P>On return from <code>call</code> or <code>post_call</code> <code>true</code> indicates success and causes forward execution, and <code>false</code> indicates failure and causes backtracking.</P>
</DD>
</DL>
<HR>

<H3 id="Mark">Mark</H3>
<PRE>
<a href="Pro_TrailMark_class_doc.html"><CODE>Pro_TrailMark</CODE></A> <B>Mark</B></PRE>
<DL>
<DD>Controls backtracking of unifications.
<P>See documentation of <a href="Pro_Trail_class_doc.html"><CODE>Pro_Trail</CODE></A> for details.
</P>
</DD>
</DL>
<HR>

<H3 id="op_found">op_found</H3>
<PRE>
<CODE>boolean</CODE> <B>op_found</B></PRE>
<DL>
<DD>Rarely needed. Is <code>true</code> when <code>first_call</code> is called. If set to <code>false</code> the predicate is searched from the database after the return from <code>first_call</code>.
</DD>
</DL>
<HR>

<H3 id="trail">trail</H3>
<PRE>
<a href="Pro_Trail_class_doc.html"><CODE>Pro_Trail</CODE></A> <B>trail</B></PRE>
<DL>
<DD>Used for cancelling unifications on backtracking.
<P>See documentation of <a href="Pro_Trail_class_doc.html"><CODE>Pro_Trail</CODE></A> for details.
</P>
</DD>
</DL>
<HR>



<!-- ========= CONSTRUCTOR DETAIL ======== -->
<!--
<A NAME="constructor_detail"></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<H3 id="Pred">
Pred</H3>
<PRE>protected <B>Pred</B>()</PRE>
<DL>
  <DD>Initializes some fields.
</DL>
-->
<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<H3 id="first_call">first_call</H3>
<PRE>
public static Pred <B>first_call</B>(<a href="Pro_TermData_Compound_class_doc.html">Pro_TermData_Compound</a> params)</PRE>
<DL>
<DD><p>The method <code>first_call</code> must be implemented for every built-in predicate.</p> 
<p>System executes <code>first_call</code> 
when this predicate is called. The argument <code>params</code>
contains the arguments of the call in the array <code>subterm</code> and the number of arguments in the field <code>arity</code>.</p>
<p>The method <code>call</code> can be called from <code>first_call</code> if
the same algorithm is useful.</p>
<p>The field <code>forward</code> is  <code>true</code> when <code>first_call</code> 
is entered.
On return <code>forward</code> must indicate succes with <code>true</code> or failure with <code>false</code>.
<p>If other results are possibly produced on backtrack, <code>first_call</code> must 
create an object of its class and initialize it with any data that
is needed on backtrack. The created object must be returned as the value
of this function.</p>
<p>If no other results may be produced on backtrack, <code>null</code> must be returned. <code>null</code> must also be returned if <code>forward</code> is <code>false</code></p>

</DD>
<P>
<DD>
<DL>
  <DT><B>Parameters:</B>
  <DD><CODE>params</CODE> - the calling term with arguments as subterms
  <DT><B>Returns:</B>
  <DD><code>null</code> or an object for recall on backtrack
</DL>
</DD>
</DL>
<HR>

<H3 id="call">call</H3>
<PRE>
public void <B>call</B>()</PRE>
<DL>
<DD>
<P>The default implementation does nothing. A subclass may override this.</P>
<P>System calls this on backtrack. This can be called by <code>first_call</code>, too. If the system calls this on backtrack, <code>forward</code> is <code>false</code>. </P>
<P>Before returning <code>forward</code> must be set to <code>true</code> for success or to <code>false</code> for failure.</P>
<P>
<DD>
<DL>
</DL>
</DD>
</DL>
<HR>

<H3 id="post_call">post_call</H3>
<PRE>
public void <B>post_call</B>()</PRE>
<DL>
<DD><P>
This is called when <code>called_body</code> is executed or has failed. The field <code>forward</code> is <code>true</code> after success or <code>false</code> after failure.</P>
<P>Before returning <code>forward</code> must be set to <code>true</code> on success or to <code>false</code> on failure.
</P>
<P><code>called_body</code> must be set to <code>null</code> unless an execution of the same or another body is wanted.</P>
<P>The default implementation does nothing. A subclass may override this.</P>
<DD>
<DL>
</DL>
</DD>
</DL>
<HR>

<H3 id="toString">toString</H3>
<PRE>
public String <B>toString</B>()</PRE>
<DL>
<DD>For debugging. Prints some data of the predicate instance.
<P>
<DD>
<DL>
</DL>
</DD>
</DL>

<!-- ========= END OF CLASS DATA ========= -->
<HR>
<font size="-1">Authors: Mikko Levanto, Ari Okkonen</font>
</body>
</html>